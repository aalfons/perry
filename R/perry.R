# ----------------------
# Author: Andreas Alfons
#         KU Leuven
# ----------------------

#' Resampling-based prediction error for fitted models
#' 
#' Estimate the prediction error of a fitted model via (repeated) \eqn{K}-fold 
#' cross-validation, (repeated) random splitting (also known as random 
#' subsampling or Monte Carlo cross-validation), or the bootstrap.  Methods are 
#' available for least squares fits computed with \code{\link[stats]{lm}} as 
#' well as for the following robust alternatives: MM-type models computed with 
#' \code{\link[robustbase]{lmrob}} and least trimmed squares fits computed with 
#' \code{\link[robustbase]{ltsReg}}.
#' 
#' @param object  the fitted model for which to estimate the prediction error.
#' @param splits  an object of class \code{"cvFolds"} (as returned by 
#' \code{\link{cvFolds}}) or a control object of class \code{"foldControl"} 
#' (see \code{\link{foldControl}}) defining the folds of the data for 
#' (repeated) \eqn{K}-fold cross-validation, an object of class 
#' \code{"randomSplits"} (as returned by \code{\link{randomSplits}}) or a 
#' control object of class \code{"splitControl"} (see 
#' \code{\link{splitControl}}) defining random data splits, or an object of 
#' class \code{"bootSamples"} (as returned by \code{\link{bootSamples}}) or a 
#' control object of class \code{"bootControl"} (see \code{\link{bootControl}}) 
#' defining bootstrap samples.
#' @param fit  a character string specifying for which fit to estimate the 
#' prediction error.  Possible values are \code{"reweighted"} (the default) for 
#' the prediction error of the reweighted fit, \code{"raw"} for the prediction 
#' error of the raw fit, or \code{"both"} for the prediction error of both 
#' fits.
#' @param cost  a cost function measuring prediction loss.  It should expect 
#' the observed values of the response to be passed as the first argument and 
#' the predicted values as the second argument, and must return either a 
#' non-negative scalar value, or a list with the first component containing 
#' the prediction error and the second component containing the standard 
#' error.  The default is to use the root mean squared prediction error 
#' for the \code{"lm"} method and the root trimmed mean squared prediction 
#' error for the \code{"lmrob"} and \code{"lts"} methods (see 
#' \code{\link{cost}}).
#' @param ncores  a positive integer giving the number of processor cores to be 
#' used for parallel computing (the default is 1 for no parallelization).  If 
#' this is set to \code{NA}, all available processor cores are used.
#' @param cl  a \pkg{parallel} cluster for parallel computing as generated by 
#' \code{\link[parallel]{makeCluster}}.  If supplied, this is preferred over 
#' \code{ncores}.
#' @param seed  optional initial seed for the random number generator (see 
#' \code{\link{.Random.seed}}).  Note that also in case of parallel computing, 
#' resampling is performed on the manager process rather than the worker 
#' processes. On the parallel worker processes, random number streams are 
#' used and the seed is set via \code{\link{clusterSetRNGStream}}.
#' @param \dots  for the generic function, additional arguments to be passed 
#' down to methods.  For the methods,  additional arguments to be passed to the 
#' prediction loss function \code{cost}.
#' 
#' @returnClass perry
#' @returnItem pe  a numeric vector containing the estimated prediction 
#' errors.  For the \code{"lm"} and \code{"lmrob"} methods, this is a single 
#' numeric value.  For the \code{"lts"} method, this contains one value for 
#' each of the requested fits.  In case of more than one replication, those are 
#' average values over all replications.
#' @returnItem se  a numeric vector containing the estimated standard 
#' errors of the prediction loss.  For the \code{"lm"} and \code{"lmrob"} 
#' methods, this is a single numeric value.  For the \code{"lts"} method, this 
#' contains one value for each of the requested fits.
#' @returnItem reps  a numeric matrix containing the estimated prediction 
#' errors from all replications.  For the \code{"lm"} and \code{"lmrob"} 
#' methods, this is a matrix with one column.  For the \code{"lts"} method, 
#' this contains one column for each of the requested fits.  However, this is 
#' only returned in case of more than one replication.
#' @returnItem splits  an object giving the data splits used to estimate the 
#' prediction error.
#' @returnItem y  the response.
#' @returnItem yHat  a list containing the predicted values from all 
#' replications.
#' @returnItem seed  the seed of the random number generator before estimation 
#' of the prediction error.
#' @returnItem call  the matched function call.
#' 
#' @note The \code{perry} methods extract the data from the fitted model and 
#' call \code{\link{perryFit}} to perform resampling-based prediction error 
#' estimation.  Users may prefer the wrapper functions \code{\link{repCV}}, 
#' \code{\link{repRS}} and \code{\link{bootPE}}.
#' 
#' @author Andreas Alfons
#' 
#' @seealso \code{\link{perryFit}}, \code{\link{repCV}}, \code{\link{repRS}}, 
#' \code{\link{bootPE}}
#' 
#' @example inst/doc/examples/example-perry.R
#' 
#' @keywords utilities
#' 
#' @export

perry <- function(object, ...) UseMethod("perry")


## LS regression 
#' @rdname perry
#' @method perry lm
#' @export

perry.lm <- function(object, splits = foldControl(), cost = rmspe, 
        ncores = 1, cl = NULL, seed = NULL, ...) {
    ## initializations
    matchedCall <- match.call()
    # retrieve data from model fit
    if(is.null(data <- object$model)) {
        haveDataArgument <- !is.null(object$call$data)
        if(haveDataArgument) {
            # try to retrieve data from 'x' and 'y' components
            # this only works if the data argument was used to fit the model
            if(!is.null(x <- object[["x"]]) && !is.null(y <- object$y)) {
                x <- removeIntercept(x)
                data <- data.frame(y, x)
            }
        }
        if(!haveDataArgument || is.null(data)) {
            # try to retrieve data from terms component
            data <- try(model.frame(object$terms), silent=TRUE)
            if(inherits(data, "try-error")) stop("model data not available")
        }
    }
    if(is.null(y <- object$y)) y <- model.response(data)
    ## call function perryFit() to estimate the prediction error
    out <- perryFit(object, data=data, y=y, splits=splits, cost=cost, 
        costArgs=list(...), envir=parent.frame(), ncores=ncores, 
        cl=cl, seed=seed)
    out$call <- matchedCall
    out
}


## MM and SDMD regression
#' @rdname perry
#' @method perry lmrob
#' @export

perry.lmrob <- function(object, splits = foldControl(), cost = rtmspe, 
        ncores = 1, cl = NULL, seed = NULL, ...) {
    ## initializations
    matchedCall <- match.call()
    # retrieve data from model fit
    if(is.null(data <- object$model)) {
        haveDataArgument <- !is.null(object$call$data)
        if(haveDataArgument) {
            # try to retrieve data from 'x' and 'y' components
            # this only works if the data argument was used to fit the model
            if(!is.null(x <- object[["x"]]) && !is.null(y <- object$y)) {
                x <- removeIntercept(x)
                data <- data.frame(y, x)
            }
        }
        if(!haveDataArgument || is.null(data)) {
            # try to retrieve data from terms component
            data <- try(model.frame(object$terms), silent=TRUE)
            if(inherits(data, "try-error")) stop("model data not available")
        }
    }
    if(is.null(y <- object$y)) y <- model.response(data)
    ## call function perryFit() to estimate the prediction error
    out <- perryFit(object, data=data, y=y, splits=splits, cost=cost, 
        costArgs=list(...), envir=parent.frame(), ncores=ncores, 
        cl=cl, seed=seed)
    out$call <- matchedCall
    out
}


## LTS regression
#' @rdname perry
#' @method perry lts
#' @export

perry.lts <- function(object, splits = foldControl(), 
        fit = c("reweighted", "raw", "both"), cost = rtmspe, 
        ncores = 1, cl = NULL, seed = NULL, ...) {
    ## initializations
    matchedCall <- match.call()
    object <- object
    if(is.null(x <- object$X) || is.null(y <- object$Y)) {
        if(is.null(data <- object$model)) {
            if(is.null(x)) x <- try(model.matrix(object$terms), silent=TRUE)
            if(is.null(y)) y <- try(model.response(object$terms), silent=TRUE)
            if(inherits(x, "try-error") || inherits(y, "try-error")) {
                stop("model data not available")
            }
        } else {
            x <- model.matrix(object$terms, data)
            y <- model.response(data)
        }
    }
    # predictor matrix is stored with column for intercept (if any)
    x <- removeIntercept(x)
    ## prepare cross-validation
    # extract function call for model fit
    call <- object$call
    call[[1]] <- as.name("ltsReg")
    # if the model was fitted with formula method, 'formula' and 'data' 
    # arguments are removed from call and 'x' and 'y' are used instead
    call$formula <- NULL
    call$data <- NULL
    call$intercept <- object$intercept
    ## call function perryFit() to estimate the prediction error
    out <- perryFit(call, x=x, y=y, splits=splits, predictArgs=list(fit=fit), 
        cost=cost, costArgs=list(...), envir=parent.frame(), ncores=ncores, 
        cl=cl, seed=seed)
    out$call <- matchedCall
    out
}


#' (Repeated) cross-validation for fitted models
#' 
#' Estimate the prediction error of a fitted model via (repeated) \eqn{K}-fold 
#' cross-validation.  This works for any model for which a \code{\link{perry}} 
#' method is available.
#' 
#' @param object  the fitted model for which to estimate the prediction error.
#' @param K  an integer giving the number of folds into which the observations 
#' should be split (the default is five).  Setting \code{K} equal to the number 
#' of observations or groups yields leave-one-out cross-validation.
#' @param R  an integer giving the number of replications for repeated 
#' \eqn{K}-fold cross-validation.  This is ignored for for leave-one-out 
#' cross-validation and other non-random splits of the data.
#' @param foldType  a character string specifying the type of folds to be 
#' generated.  Possible values are \code{"random"} (the default), 
#' \code{"consecutive"} or \code{"interleaved"}.
#' @param grouping  a factor specifying groups of observations.  If supplied, 
#' the data are split according to the groups rather than individual 
#' observations such that all observations within a group belong to the same 
#' fold.
#' @param folds  an object of class \code{"cvFolds"} (as returned by 
#' \code{\link{cvFolds}}) or a control object of class \code{"foldControl"} 
#' (see \code{\link{foldControl}}) defining the folds of the data for 
#' (repeated) \eqn{K}-fold cross-validation.  If supplied, this is preferred 
#' over the arguments for generating cross-validation folds.
#' @param \dots  additional arguments to be passed down to \code{\link{perry}}.
#' 
#' @return An object of class \code{"perry"} as returned by \code{\link{perry}}.
#' 
#' @author Andreas Alfons
#' 
#' @seealso \code{\link{perry}}, \code{\link{repRS}}, \code{\link{bootPE}}
#' 
#' @example inst/doc/examples/example-repCV.R
#' 
#' @keywords utilities
#' 
#' @export

repCV <- function(object, K = 5, R = 1, 
        foldType = c("random", "consecutive", "interleaved"), 
        grouping = NULL, folds = NULL, ...) {
    ## initializations
    if(is.null(folds)) 
        folds <- foldControl(K, R, type=foldType, grouping=grouping)
    ## call function perry() to estimate the prediction error
    perry(object, splits=folds, ...)
}


#' (Repeated) random splitting for fitted models
#' 
#' Estimate the prediction error of a fitted model via (repeated) random 
#' splitting (also known as random subsampling or Monte Carlo 
#' cross-validation).  This works for any model for which a 
#' \code{\link{perry}} method is available.
#' 
#' @param object  the fitted model for which to estimate the prediction error.
#' @param m  an integer giving the number of observations or groups of 
#' observations to be used as test data.
#' @param R  an integer giving the number of random data splits.
#' @param grouping  a factor specifying groups of observations.  If supplied, 
#' the data are split according to the groups rather than individual 
#' observations such that all observations within a group belong either to the 
#' training or test data.
#' @param splits  an object of class \code{"randomSplits"} (as returned by 
#' \code{\link{randomSplits}}) or a control object of class 
#' \code{"splitControl"} (see \code{\link{splitControl}}) defining random data 
#' splits.  If supplied, this is preferred over the arguments for generating 
#' random data splits.
#' @param \dots  additional arguments to be passed down to \code{\link{perry}}.
#' 
#' @return An object of class \code{"perry"} as returned by \code{\link{perry}}.
#' 
#' @author Andreas Alfons
#' 
#' @seealso \code{\link{perry}}, \code{\link{repCV}}, \code{\link{bootPE}}
#' 
#' @example inst/doc/examples/example-repRS.R
#' 
#' @keywords utilities
#' 
#' @export

repRS <- function(object, m, R = 1, grouping = NULL, splits = NULL, ...) {
    ## initializations
    if(is.null(splits)) splits <- splitControl(m, R, grouping=grouping)
    ## call function perry() to estimate the prediction error
    perry(object, splits=splits, ...)
}


#' Bootstrap prediction error estimation for fitted models
#' 
#' Estimate the prediction error of a fitted model via the bootstrap.  This 
#' works for any model for which a \code{\link{perry}} method is available.
#' 
#' @param object  the fitted model for which to estimate the prediction error.
#' @param R  an integer giving the number of bootstrap samples.
#' @param bootType  a character string specifying a bootstrap 
#' estimator.  Possible values are \code{"0.632"} (the default), 
#' or \code{"out-of-bag"}.
#' @param grouping  a factor specifying groups of observations.  If supplied, 
#' the groups are resampled rather than individual observations such that all 
#' observations within a group belong either to the bootstrap sample or the 
#' test data.
#' @param samples  an object of class \code{"bootSamples"} (as returned by 
#' \code{\link{bootSamples}}) or a control object of class \code{"bootControl"} 
#' (see \code{\link{bootControl}}) defining bootstrap samples.  If supplied, 
#' this is preferred over the arguments for generating bootstrap samples.
#' @param \dots  additional arguments to be passed down to \code{\link{perry}}.
#' 
#' @return An object of class \code{"perry"} as returned by \code{\link{perry}}.
#' 
#' @author Andreas Alfons
#' 
#' @seealso \code{\link{perry}}, \code{\link{repCV}}, \code{\link{repRS}}
#' 
#' @example inst/doc/examples/example-bootPE.R
#' 
#' @keywords utilities
#' 
#' @export

bootPE <- function(object, R = 1, bootType = c("0.632", "out-of-bag"), 
        grouping = NULL, samples = NULL, ...) {
    ## initializations
    if(is.null(samples)) 
        samples <- bootControl(R, type=bootType, grouping=grouping)
    ## call function perry() to estimate the prediction error
    perry(object, splits=samples, ...)
}
