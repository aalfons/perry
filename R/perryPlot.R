# --------------------------------------
# Author: Andreas Alfons
#         Erasmus Universiteit Rotterdam
# --------------------------------------

#' Plot resampling-based prediction error results
#'
#' Plot results of resampling-based prediction error measures.
#'
#' For objects with multiple columns of prediction error results, conditional
#' plots are produced.
#'
#' @param x  an object inheriting from class \code{"perry"} or
#' \code{"perrySelect"} that contains prediction error results, or an object of
#' class \code{"setupPerryPlot"} containing all necessary information for
#' plotting (as generated by \code{\link{setupPerryPlot}}).
#' @param object  an object inheriting from class \code{"perry"} or
#' \code{"perrySelect"}.
#' @param method  a character string specifying the type of plot.  Possible
#' values are \code{"box"} to create a box plot, \code{"density"} to create a
#' smooth density plot, \code{"dot"} to create a dot plot, or \code{"line"} to
#' plot the (average) results for each model as a connected line (for objects
#' inheriting from class \code{"perrySelect"}).  Note that the first two plots
#' are only meaningful in case of repeated resampling.  The default is to use
#' \code{"box"} in case of repeated resampling and \code{"dot"} otherwise.  In
#' any case, partial string matching allows supply abbreviations of the
#' accepted values.
#' @param subset  a character, integer or logical vector indicating the subset
#' of models for which to plot the prediction error results.
#' @param select  a character, integer or logical vector indicating the columns
#' of prediction error results to be plotted.
#' @param seFactor  a numeric value giving the multiplication factor of the
#' standard error for displaying error bars in dot plots or line plots.  Error
#' bars in those plots can be suppressed by setting this to \code{NA}.
#' @param mapping  an aesthetic mapping to override the default behavior (see
#' \code{\link[ggplot2]{aes}} or \code{\link[ggplot2]{aes_string}}).
#' @param facets  a faceting formula to override the default behavior.  If
#' supplied, \code{\link[ggplot2]{facet_wrap}} or
#' \code{\link[ggplot2]{facet_grid}} is called depending on whether the formula
#' is one-sided or two-sided.
#' @param \dots  for the generic function \code{perryPlot}, additional
#' arguments to be passed down to methods.  For the \code{"perry"} and
#' \code{"perrySelect"} methods of \code{perryPlot}, additional arguments
#' to be passed down to the \code{"setupPerryPlot"} method.  For the
#' \code{"setupPerryPlot"} method of \code{perryPlot}, additional arguments
#' to be passed down to \code{\link[ggplot2]{geom_boxplot}},
#' \code{\link[ggplot2]{geom_density}}, \code{\link[ggplot2]{geom_pointrange}}
#' (or \code{\link[ggplot2]{geom_point}}), or \code{\link[ggplot2]{geom_line}}.
#' For the methods of \code{plot} or \code{autoplot}, additional arguments to
#' be passed down to \code{perryPlot}.
#'
#' @return
#' An object of class \code{"ggplot"} (see \code{\link[ggplot2]{ggplot}}).
#'
#' @note Duplicate indices in \code{subset} or \code{select} are removed such
#' that all models and prediction error results are unique.
#'
#' @author Andreas Alfons
#'
#' @seealso
#' \code{\link{setupPerryPlot}},
#'
#' \code{\link{perryFit}}, \code{\link{perrySelect}},
#' \code{\link{perryTuning}},
#'
#' \code{\link[ggplot2]{ggplot}}, \code{\link[ggplot2]{autoplot}},
#' \code{\link[graphics]{plot}}
#'
#' @example inst/doc/examples/example-perryPlot.R
#'
#' @keywords hplot
#'
#' @import ggplot2
#' @export

perryPlot <- function(x, ...) UseMethod("perryPlot")


#' @rdname perryPlot
#' @method perryPlot perry
#' @export

perryPlot.perry <- function(x, method = c("box", "density", "dot"),
                            select = NULL, seFactor = NA, ...) {
    # initializations
    if (x$splits$R == 1) method <- "dot"
    else method <- match.arg(method)
    # extract data for plotting
    reps <- method %in% c("box", "density")
    setup <- setupPerryPlot(x, select = select, reps = reps,
                            seFactor = seFactor)
    # call "setupPerryPlot" method
    perryPlot(setup, method = method, ...)
}


#' @rdname perryPlot
#' @method perryPlot perrySelect
#' @export

perryPlot.perrySelect <- function(x,
                                  method = c("box", "density", "dot", "line"),
                                  subset = NULL, select = NULL,
                                  seFactor = x$seFactor, ...) {
    # initializations
    if (x$splits$R == 1) {
        choices <- eval(formals()[["method"]])
        if (identical(method, choices)) method <- "dot"
        else method <- match.arg(method, c("dot", "line"))
    } else method <- match.arg(method)
    # extract data for plotting
    reps <- method %in% c("box", "density")
    setup <- setupPerryPlot(x, subset = subset, select = select,
                            reps = reps, seFactor = seFactor)
    # call "setupPerryPlot" method
    perryPlot(setup, method = method, ...)
}


#' @rdname perryPlot
#' @method perryPlot setupPerryPlot
#' @export

perryPlot.setupPerryPlot <- function(x,
                                     method = c("box", "density", "dot", "line"),
                                     mapping = NULL, facets = x$facets, ...) {
    # initializations
    if (is.null(x$method)) {
        choices <- eval(formals()[["method"]])
        if (x$reps) {
            # multiple replications not aggregated
            if (identical(method, choices)) method <- "box"
            else method <- match.arg(method, c("box", "density"))
        } else {
            # either only one replication or aggregated results
            if (identical(method, choices)) method <- "dot"
            else method <- match.arg(method, c("dot", "line"))
        }
    }
    # call function for selected plot
    if (method == "box") {
        boxPlot(x, mapping = mapping, facets = facets, ...)
    } else if(method == "density") {
        densityPlot(x, mapping = mapping, facets = facets, ...)
    } else if(method == "line") {
        linePlot(x, mapping = mapping, facets = facets, ...)
    } else dotPlot(x, mapping = mapping, facets = facets, ...)
}


#' @rdname perryPlot
#' @method autoplot perry
#' @export

autoplot.perry <- function(object, ...) perryPlot(object, ...)


#' @rdname perryPlot
#' @method autoplot perrySelect
#' @export

autoplot.perrySelect <- function(object, ...) perryPlot(object, ...)


#' @rdname perryPlot
#' @method plot perry
#' @export

plot.perry <- function(x, ...) perryPlot(x, ...)


#' @rdname perryPlot
#' @method plot perrySelect
#' @export

plot.perrySelect <- function(x, ...) perryPlot(x, ...)

# ----------

boxPlot <- function(object, mapping = NULL, facets = object$facets, ...) {
    # define aesthetic mapping for box plot
    if (is.null(mapping)) {
        mapping <- aes_string(x = "Fit", y = "PE", group = "Fit")
    }
    # generate plot
    p <- ggplot(object$data, mapping) + geom_boxplot(...) +
        labs(x = NULL, y = "Prediction error")
    if (!is.null(facets)) {
        # split plot into different panels
        if (length(facets) == 2) p <- p + facet_wrap(facets)
        else p <- p + facet_grid(facets)
    }
    p
}

# ----------

densityPlot <- function(object, mapping = NULL, facets = object$facets, ...) {
    # initializations
    data <- object$data
    # define aesthetic mapping for density plot
    if (is.null(mapping)) {
        if(nlevels(data[, "Fit"]) > 1 || length(unique(data[, "Fit"])) > 1) {
            mapping <- aes_string(x = "PE", group = "Fit", color = "Fit")
        } else mapping <- aes_string(x = "PE")
    }
    # generate plot
    p <- ggplot(data, mapping) + geom_density(...) +
        labs(x = "Prediction error", y = NULL)
    if (is.numeric(data[, "Fit"]))
        p <- p + scale_color_continuous(breaks = unique(data[, "Fit"]))
    if (!is.null(facets)) {
        # split plot into different panels
        if (length(facets) == 2) p <- p + facet_wrap(facets)
        else p <- p + facet_grid(facets)
    }
    p
}

# ----------

dotPlot <- function(object, mapping = NULL, facets = object$facets, ...) {
    # initializations
    includeSE <- !object$reps && object$includeSE
    # define aesthetic mapping for box plot
    if (is.null(mapping)) {
        if (includeSE) {
            mapping <- aes_string(x = "Fit", y = "PE", ymin = "Lower",
                                  ymax = "Upper")
        } else mapping <- aes_string(x = "Fit", y = "PE")
    }
    # generate plot
    p <- ggplot(object$data, mapping)
    if (includeSE) p <- p + geom_pointrange(...)
    else p <- p + geom_point(...)
    p <- p + labs(x = NULL, y = "Prediction error")
    if (!is.null(facets)) {
        # split plot into different panels
        if (length(facets) == 2) p <- p + facet_wrap(facets)
        else p <- p + facet_grid(facets)
    }
    p
}

# ----------

linePlot <- function(object, mapping = NULL, facets = object$facets, ...) {
    # initializations
    includeSE <- !object$reps && object$includeSE
    # define aesthetic mapping for box plot
    if (is.null(mapping)) {
        if (includeSE) {
            mapping <- aes_string(x = "Fit", y = "PE", ymin = "Lower",
                                  ymax = "Upper")
        } else mapping <- aes_string(x = "Fit", y = "PE")
    }
    # generate plot
    p <- ggplot(object$data, mapping) + geom_line(...)
    if (includeSE) p <- p + geom_pointrange(...)
    else p <- p + geom_point(...)
    p <- p + labs(x = NULL, y = "Prediction error")
    if (!is.null(facets)) {
        # split plot into different panels
        if (length(facets) == 2) p <- p + facet_wrap(facets)
        else p <- p + facet_grid(facets)
    }
    p
}
